<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Amoeba IO</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-family: Arial, sans-serif;
            color: #aaa;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="instructions">Touch & Drag to Move</div>
    
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- 1. SETUP SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f7); // Light gray/white background like video

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 2. THE AMOEBA SHADER (The "Magic" Part) ---
        // This recreates the wobbly, iridescent look from your video using math.
        const vertexShader = `
            uniform float uTime;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;

            // Simplex noise function to make it "wobbly"
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
                i = mod289(i);
                vec4 p = permute( permute( permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; // 1.0/7.0
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                            dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vUv = uv;
                vNormal = normal;
                
                // Add noise to position to make it "organic"
                float noiseVal = snoise(position * 1.5 + uTime * 0.5);
                
                // Displace vertices along normal
                vec3 newPos = position + normal * (noiseVal * 0.3);
                
                vPosition = newPos;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                // Iridescent Rainbow Colors
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(-vPosition); // Simplified view direction
                
                // Calculate "Fresnel" (rim lighting) for that glowing edge look
                float fresnel = dot(normal, viewDir);
                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                fresnel = pow(fresnel, 2.0); // Sharpen the rim
                
                // Define rainbow colors
                vec3 colorA = vec3(0.5, 0.8, 1.0); // Light Blue center
                vec3 colorB = vec3(1.0, 0.0, 0.8); // Pink/Purple edge
                vec3 colorC = vec3(0.0, 1.0, 1.0); // Cyan
                
                // Mix based on fresnel
                vec3 finalColor = mix(colorA, colorB, fresnel);
                finalColor += colorC * fresnel * 0.5; // Add extra glow
                
                gl_FragColor = vec4(finalColor, 0.9); // Slight transparency look
            }
        `;

        // --- 3. CREATE THE BLOB ---
        const geometry = new THREE.SphereGeometry(1, 128, 128); // High detail sphere
        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0.0 }
            },
            transparent: true
        });

        const blob = new THREE.Mesh(geometry, material);
        scene.add(blob);

        // --- 4. TOUCH & MOUSE INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Target position for the blob to follow (smooth movement)
        const targetPos = new THREE.Vector3(0, 0, 0);

        function updateInput(x, y) {
            // Convert screen X/Y to Normalized Device Coordinates (-1 to +1)
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;

            // Raycast to find where on the "z=0" plane the finger is pointing
            raycaster.setFromCamera(mouse, camera);
            
            // Create a virtual plane at z=0 to intersect with
            const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(planeZ, intersection);
            
            if (intersection) {
                targetPos.copy(intersection);
            }
        }

        // Mouse Listeners (for Desktop testing)
        window.addEventListener('mousemove', (e) => {
            updateInput(e.clientX, e.clientY);
        });

        // Touch Listeners (for iPhone)
        window.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Stop scrolling
            const touch = e.touches[0];
            updateInput(touch.clientX, touch.clientY);
        }, { passive: false });

        window.addEventListener('touchstart', (e) => {
             const touch = e.touches[0];
             updateInput(touch.clientX, touch.clientY);
        }, { passive: false });


        // --- 5. ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Update Shader Uniforms (Wobble Animation)
            material.uniforms.uTime.value = elapsedTime;

            // Smoothly move blob to finger position (Linear Interpolation "Lerp")
            blob.position.lerp(targetPos, 0.1);

            // Add a little rotation for style
            blob.rotation.z = elapsedTime * 0.1;
            blob.rotation.x = elapsedTime * 0.05;

            renderer.render(scene, camera);
        }

        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
